// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createAnsprechpartner = `-- name: CreateAnsprechpartner :execresult
INSERT INTO
    Anschprechpartner (id, Name, Telefon, Mobil, Mail, lieferantenId)
VALUES
    (?, ?, ?, ?, ?, ?)
`

type CreateAnsprechpartnerParams struct {
	ID            string
	Name          string
	Telefon       sql.NullString
	Mobil         sql.NullString
	Mail          sql.NullString
	Lieferantenid sql.NullString
}

func (q *Queries) CreateAnsprechpartner(ctx context.Context, arg CreateAnsprechpartnerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAnsprechpartner,
		arg.ID,
		arg.Name,
		arg.Telefon,
		arg.Mobil,
		arg.Mail,
		arg.Lieferantenid,
	)
}

const createEinkauf = `-- name: CreateEinkauf :execresult
INSERT INTO
    Einkauf (
        id,
        Paypal,
        Abonniert,
        Geld,
        Pfand,
        Dinge,
        mitarbeiterId,
        Abgeschickt,
        Bild1,
        Bild2,
        Bild3,
        Bild1Date,
        Bild2Date,
        Bild3Date
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?)
`

type CreateEinkaufParams struct {
	ID            string
	Paypal        bool
	Abonniert     bool
	Geld          sql.NullString
	Pfand         sql.NullString
	Dinge         sql.NullString
	Mitarbeiterid string
	Bild1         sql.NullString
	Bild2         sql.NullString
	Bild3         sql.NullString
	Bild1date     sql.NullTime
	Bild2date     sql.NullTime
	Bild3date     sql.NullTime
}

func (q *Queries) CreateEinkauf(ctx context.Context, arg CreateEinkaufParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEinkauf,
		arg.ID,
		arg.Paypal,
		arg.Abonniert,
		arg.Geld,
		arg.Pfand,
		arg.Dinge,
		arg.Mitarbeiterid,
		arg.Bild1,
		arg.Bild2,
		arg.Bild3,
		arg.Bild1date,
		arg.Bild2date,
		arg.Bild3date,
	)
}

const createLieferant = `-- name: CreateLieferant :execresult
INSERT INTO
    Lieferanten (id, Firma, Kundennummer, Webseite)
VALUES
    (?, ?, ?, ?)
`

type CreateLieferantParams struct {
	ID           string
	Firma        string
	Kundennummer sql.NullString
	Webseite     sql.NullString
}

func (q *Queries) CreateLieferant(ctx context.Context, arg CreateLieferantParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createLieferant,
		arg.ID,
		arg.Firma,
		arg.Kundennummer,
		arg.Webseite,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO
    Mitarbeiter (
        id,
        Name,
        Short,
        Gruppenwahl,
        InternTelefon1,
        InternTelefon2,
        FestnetzAlternativ,
        FestnetzPrivat,
        HomeOffice,
        MobilBusiness,
        MobilPrivat,
        Email,
        Azubi,
        Geburtstag
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	ID                 string
	Name               string
	Short              sql.NullString
	Gruppenwahl        sql.NullString
	Interntelefon1     sql.NullString
	Interntelefon2     sql.NullString
	Festnetzalternativ sql.NullString
	Festnetzprivat     sql.NullString
	Homeoffice         sql.NullString
	Mobilbusiness      sql.NullString
	Mobilprivat        sql.NullString
	Email              sql.NullString
	Azubi              sql.NullBool
	Geburtstag         sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Short,
		arg.Gruppenwahl,
		arg.Interntelefon1,
		arg.Interntelefon2,
		arg.Festnetzalternativ,
		arg.Festnetzprivat,
		arg.Homeoffice,
		arg.Mobilbusiness,
		arg.Mobilprivat,
		arg.Email,
		arg.Azubi,
		arg.Geburtstag,
	)
}

const createWiki = `-- name: CreateWiki :execresult
INSERT INTO Wiki (id, Name, Inhalt) VALUES(?, ?, ?)
`

type CreateWikiParams struct {
	ID     string
	Name   string
	Inhalt string
}

func (q *Queries) CreateWiki(ctx context.Context, arg CreateWikiParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createWiki, arg.ID, arg.Name, arg.Inhalt)
}

const deleteAnsprechpartner = `-- name: DeleteAnsprechpartner :exec
DELETE FROM Anschprechpartner
WHERE
    id = ?
`

func (q *Queries) DeleteAnsprechpartner(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAnsprechpartner, id)
	return err
}

const deleteEinkauf = `-- name: DeleteEinkauf :exec
DELETE FROM
    Einkauf
WHERE
    id = ?
`

func (q *Queries) DeleteEinkauf(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteEinkauf, id)
	return err
}

const deleteEinkaufFromUser = `-- name: DeleteEinkaufFromUser :exec
DELETE FROM Einkauf WHERE mitarbeiterId = ?
`

func (q *Queries) DeleteEinkaufFromUser(ctx context.Context, mitarbeiterid string) error {
	_, err := q.db.ExecContext(ctx, deleteEinkaufFromUser, mitarbeiterid)
	return err
}

const deleteLieferant = `-- name: DeleteLieferant :exec
DELETE FROM
    Lieferanten
WHERE
    id = ?
`

func (q *Queries) DeleteLieferant(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLieferant, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM
    Mitarbeiter
WHERE
    id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteWiki = `-- name: DeleteWiki :exec
DELETE FROM Wiki WHERE id = ?
`

func (q *Queries) DeleteWiki(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWiki, id)
	return err
}

const getAnsprechpartner = `-- name: GetAnsprechpartner :one
SELECT
    id, name, telefon, mobil, mail, lieferantenid
FROM
    Anschprechpartner
WHERE
    id = ?
`

func (q *Queries) GetAnsprechpartner(ctx context.Context, id string) (Anschprechpartner, error) {
	row := q.db.QueryRowContext(ctx, getAnsprechpartner, id)
	var i Anschprechpartner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Telefon,
		&i.Mobil,
		&i.Mail,
		&i.Lieferantenid,
	)
	return i, err
}

const getAnsprechpartnerFromLiegerant = `-- name: GetAnsprechpartnerFromLiegerant :many
SELECT
    id, name, telefon, mobil, mail, lieferantenid
FROM
    Anschprechpartner
WHERE
    lieferantenId = ?
`

func (q *Queries) GetAnsprechpartnerFromLiegerant(ctx context.Context, lieferantenid sql.NullString) ([]Anschprechpartner, error) {
	rows, err := q.db.QueryContext(ctx, getAnsprechpartnerFromLiegerant, lieferantenid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anschprechpartner
	for rows.Next() {
		var i Anschprechpartner
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Telefon,
			&i.Mobil,
			&i.Mail,
			&i.Lieferantenid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyDelivered = `-- name: GetDailyDelivered :many
SELECT Name, Artikelnummer FROM Warenlieferung WHERE DATE_FORMAT(geliefert, '%Y-%m-%d') = DATE_FORMAT(NOW(), '%Y-%m-%d') AND DATE_FORMAT(angelegt, '%Y-%m-%d') != DATE_FORMAT(NOW(), '%Y-%m-%d') ORDER BY Artikelnummer ASC
`

type GetDailyDeliveredRow struct {
	Name          string
	Artikelnummer string
}

func (q *Queries) GetDailyDelivered(ctx context.Context) ([]GetDailyDeliveredRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyDelivered)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyDeliveredRow
	for rows.Next() {
		var i GetDailyDeliveredRow
		if err := rows.Scan(&i.Name, &i.Artikelnummer); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyNew = `-- name: GetDailyNew :many
SELECT Name, Artikelnummer FROM Warenlieferung WHERE DATE_FORMAT(angelegt, '%Y-%m-%d') = DATE_FORMAT(NOW(), '%Y-%m-%d') ORDER BY Artikelnummer ASC
`

type GetDailyNewRow struct {
	Name          string
	Artikelnummer string
}

func (q *Queries) GetDailyNew(ctx context.Context) ([]GetDailyNewRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyNew)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyNewRow
	for rows.Next() {
		var i GetDailyNewRow
		if err := rows.Scan(&i.Name, &i.Artikelnummer); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyWarenlieferung = `-- name: GetDailyWarenlieferung :many
SELECT Name, Artikelnummer, AlterPreis, NeuerPreis FROM Warenlieferung WHERE DATE_FORMAT(Preis, '%Y-%m-%d') = DATE_FORMAT(NOW(), '%Y-%m-%d') AND DATE_FORMAT(angelegt, '%Y-%m-%d') != DATE_FORMAT(NOW(), '%Y-%m-%d') ORDER BY Artikelnummer ASC
`

type GetDailyWarenlieferungRow struct {
	Name          string
	Artikelnummer string
	Alterpreis    sql.NullString
	Neuerpreis    sql.NullString
}

func (q *Queries) GetDailyWarenlieferung(ctx context.Context) ([]GetDailyWarenlieferungRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyWarenlieferung)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyWarenlieferungRow
	for rows.Next() {
		var i GetDailyWarenlieferungRow
		if err := rows.Scan(
			&i.Name,
			&i.Artikelnummer,
			&i.Alterpreis,
			&i.Neuerpreis,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEinkauf = `-- name: GetEinkauf :one
SELECT
    id, paypal, abonniert, geld, pfand, dinge, mitarbeiterid, abgeschickt, bild1, bild2, bild3, bild1date, bild2date, bild3date
FROM
    Einkauf
WHERE
    mitarbeiterId = ?
LIMIT
    1
`

func (q *Queries) GetEinkauf(ctx context.Context, mitarbeiterid string) (Einkauf, error) {
	row := q.db.QueryRowContext(ctx, getEinkauf, mitarbeiterid)
	var i Einkauf
	err := row.Scan(
		&i.ID,
		&i.Paypal,
		&i.Abonniert,
		&i.Geld,
		&i.Pfand,
		&i.Dinge,
		&i.Mitarbeiterid,
		&i.Abgeschickt,
		&i.Bild1,
		&i.Bild2,
		&i.Bild3,
		&i.Bild1date,
		&i.Bild2date,
		&i.Bild3date,
	)
	return i, err
}

const getEinkaufListe = `-- name: GetEinkaufListe :many
SELECT
    Einkauf.id,
    Einkauf.Paypal,
    Einkauf.Abonniert,
    Einkauf.Geld,
    Einkauf.Pfand,
    Einkauf.Dinge,
    Einkauf.Bild1,
    Einkauf.Bild2,
    Einkauf.Bild3,
    Einkauf.Bild1Date,
    Einkauf.Bild2Date,
    Einkauf.Bild3Date,
    Mitarbeiter.Name,
    Mitarbeiter.Email
FROM
    Einkauf
    LEFT JOIN Mitarbeiter ON Einkauf.mitarbeiterId = Mitarbeiter.id
WHERE
    DATEDIFF (NOW(), Einkauf.Abgeschickt) = 0
    OR Einkauf.Abonniert = 1
ORDER BY
    Einkauf.Abgeschickt DESC
`

type GetEinkaufListeRow struct {
	ID        string
	Paypal    bool
	Abonniert bool
	Geld      sql.NullString
	Pfand     sql.NullString
	Dinge     sql.NullString
	Bild1     sql.NullString
	Bild2     sql.NullString
	Bild3     sql.NullString
	Bild1date sql.NullTime
	Bild2date sql.NullTime
	Bild3date sql.NullTime
	Name      sql.NullString
	Email     sql.NullString
}

func (q *Queries) GetEinkaufListe(ctx context.Context) ([]GetEinkaufListeRow, error) {
	rows, err := q.db.QueryContext(ctx, getEinkaufListe)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEinkaufListeRow
	for rows.Next() {
		var i GetEinkaufListeRow
		if err := rows.Scan(
			&i.ID,
			&i.Paypal,
			&i.Abonniert,
			&i.Geld,
			&i.Pfand,
			&i.Dinge,
			&i.Bild1,
			&i.Bild2,
			&i.Bild3,
			&i.Bild1date,
			&i.Bild2date,
			&i.Bild3date,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLieferant = `-- name: GetLieferant :one
SELECT
    id, firma, kundennummer, webseite
FROM
    Lieferanten
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetLieferant(ctx context.Context, id string) (Lieferanten, error) {
	row := q.db.QueryRowContext(ctx, getLieferant, id)
	var i Lieferanten
	err := row.Scan(
		&i.ID,
		&i.Firma,
		&i.Kundennummer,
		&i.Webseite,
	)
	return i, err
}

const getLieferantWithAnsprechpartner = `-- name: GetLieferantWithAnsprechpartner :many
SELECT lieferanten.id, firma, kundennummer, webseite, anschprechpartner.id, name, telefon, mobil, mail, lieferantenid FROM Lieferanten INNER JOIN Anschprechpartner ON lieferanten.id = anschprechpartner.lieferantenId WHERE lieferanten.id = ?
`

type GetLieferantWithAnsprechpartnerRow struct {
	ID            string
	Firma         string
	Kundennummer  sql.NullString
	Webseite      sql.NullString
	ID_2          string
	Name          string
	Telefon       sql.NullString
	Mobil         sql.NullString
	Mail          sql.NullString
	Lieferantenid sql.NullString
}

func (q *Queries) GetLieferantWithAnsprechpartner(ctx context.Context, id string) ([]GetLieferantWithAnsprechpartnerRow, error) {
	rows, err := q.db.QueryContext(ctx, getLieferantWithAnsprechpartner, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLieferantWithAnsprechpartnerRow
	for rows.Next() {
		var i GetLieferantWithAnsprechpartnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Firma,
			&i.Kundennummer,
			&i.Webseite,
			&i.ID_2,
			&i.Name,
			&i.Telefon,
			&i.Mobil,
			&i.Mail,
			&i.Lieferantenid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLieferanten = `-- name: GetLieferanten :many
SELECT
    id, firma, kundennummer, webseite
FROM
    Lieferanten
ORDER BY
    Firma
`

func (q *Queries) GetLieferanten(ctx context.Context) ([]Lieferanten, error) {
	rows, err := q.db.QueryContext(ctx, getLieferanten)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lieferanten
	for rows.Next() {
		var i Lieferanten
		if err := rows.Scan(
			&i.ID,
			&i.Firma,
			&i.Kundennummer,
			&i.Webseite,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
    id, name, short, gruppenwahl, interntelefon1, interntelefon2, festnetzalternativ, festnetzprivat, homeoffice, mobilbusiness, mobilprivat, email, azubi, geburtstag
FROM
    Mitarbeiter
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetUser(ctx context.Context, id string) (Mitarbeiter, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i Mitarbeiter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Short,
		&i.Gruppenwahl,
		&i.Interntelefon1,
		&i.Interntelefon2,
		&i.Festnetzalternativ,
		&i.Festnetzprivat,
		&i.Homeoffice,
		&i.Mobilbusiness,
		&i.Mobilprivat,
		&i.Email,
		&i.Azubi,
		&i.Geburtstag,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT
    id, name, short, gruppenwahl, interntelefon1, interntelefon2, festnetzalternativ, festnetzprivat, homeoffice, mobilbusiness, mobilprivat, email, azubi, geburtstag
FROM
    Mitarbeiter
ORDER BY
    Name
`

func (q *Queries) GetUsers(ctx context.Context) ([]Mitarbeiter, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mitarbeiter
	for rows.Next() {
		var i Mitarbeiter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Short,
			&i.Gruppenwahl,
			&i.Interntelefon1,
			&i.Interntelefon2,
			&i.Festnetzalternativ,
			&i.Festnetzprivat,
			&i.Homeoffice,
			&i.Mobilbusiness,
			&i.Mobilprivat,
			&i.Email,
			&i.Azubi,
			&i.Geburtstag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWarenlieferung = `-- name: GetWarenlieferung :many
SELECT id, name, angelegt, geliefert, alterpreis, neuerpreis, preis, artikelnummer FROM Warenlieferung
`

func (q *Queries) GetWarenlieferung(ctx context.Context) ([]Warenlieferung, error) {
	rows, err := q.db.QueryContext(ctx, getWarenlieferung)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Warenlieferung
	for rows.Next() {
		var i Warenlieferung
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Angelegt,
			&i.Geliefert,
			&i.Alterpreis,
			&i.Neuerpreis,
			&i.Preis,
			&i.Artikelnummer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWiki = `-- name: GetWiki :one
SELECT id, name, inhalt, created_at FROM Wiki WHERE id = ? LIMIT 1
`

func (q *Queries) GetWiki(ctx context.Context, id string) (Wiki, error) {
	row := q.db.QueryRowContext(ctx, getWiki, id)
	var i Wiki
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Inhalt,
		&i.CreatedAt,
	)
	return i, err
}

const getWikis = `-- name: GetWikis :many
SELECT id, name, inhalt, created_at FROM Wiki ORDER BY created_at DESC
`

func (q *Queries) GetWikis(ctx context.Context) ([]Wiki, error) {
	rows, err := q.db.QueryContext(ctx, getWikis)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wiki
	for rows.Next() {
		var i Wiki
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Inhalt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAussteller = `-- name: InsertAussteller :execresult
INSERT INTO Aussteller (id, Artikelnummer, Artikelname, Specs, Preis) VALUES (?, ?, ?,?,?) ON DUPLICATE KEY UPDATE Artikelname = ?, Specs = ?, Preis = ?
`

type InsertAusstellerParams struct {
	ID            int32
	Artikelnummer string
	Artikelname   string
	Specs         string
	Preis         string
	Artikelname_2 string
	Specs_2       string
	Preis_2       string
}

func (q *Queries) InsertAussteller(ctx context.Context, arg InsertAusstellerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertAussteller,
		arg.ID,
		arg.Artikelnummer,
		arg.Artikelname,
		arg.Specs,
		arg.Preis,
		arg.Artikelname_2,
		arg.Specs_2,
		arg.Preis_2,
	)
}

const insertWarenlieferung = `-- name: InsertWarenlieferung :execresult
INSERT INTO Warenlieferung (id, Name, angelegt, Artikelnummer) VALUES(?, ?, NOW(), ?)
`

type InsertWarenlieferungParams struct {
	ID            int32
	Name          string
	Artikelnummer string
}

func (q *Queries) InsertWarenlieferung(ctx context.Context, arg InsertWarenlieferungParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertWarenlieferung, arg.ID, arg.Name, arg.Artikelnummer)
}

const searchArchive = `-- name: SearchArchive :many
SELECT id, title  FROM pdfs WHERE title LIKE ? OR body LIKE ?
`

type SearchArchiveParams struct {
	Title string
	Body  string
}

type SearchArchiveRow struct {
	ID    int32
	Title string
}

func (q *Queries) SearchArchive(ctx context.Context, arg SearchArchiveParams) ([]SearchArchiveRow, error) {
	rows, err := q.db.QueryContext(ctx, searchArchive, arg.Title, arg.Body)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchArchiveRow
	for rows.Next() {
		var i SearchArchiveRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const skipEinkauf = `-- name: SkipEinkauf :exec
UPDATE
    Einkauf
SET
    Abgeschickt = ?
WHERE
    id = ?
`

type SkipEinkaufParams struct {
	Abgeschickt sql.NullTime
	ID          string
}

func (q *Queries) SkipEinkauf(ctx context.Context, arg SkipEinkaufParams) error {
	_, err := q.db.ExecContext(ctx, skipEinkauf, arg.Abgeschickt, arg.ID)
	return err
}

const updateAnsprechpartner = `-- name: UpdateAnsprechpartner :execresult
UPDATE
    Anschprechpartner
SET
    Name = ?,
    Telefon = ?,
    Mobil = ?,
    Mail = ?,
    lieferantenId = ?
WHERE
    id = ?
`

type UpdateAnsprechpartnerParams struct {
	Name          string
	Telefon       sql.NullString
	Mobil         sql.NullString
	Mail          sql.NullString
	Lieferantenid sql.NullString
	ID            string
}

func (q *Queries) UpdateAnsprechpartner(ctx context.Context, arg UpdateAnsprechpartnerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAnsprechpartner,
		arg.Name,
		arg.Telefon,
		arg.Mobil,
		arg.Mail,
		arg.Lieferantenid,
		arg.ID,
	)
}

const updateEinkauf = `-- name: UpdateEinkauf :execresult
UPDATE
    Einkauf
SET
    Paypal = ?,
    Abonniert = ?,
    Geld = ?,
    Pfand = ?,
    Dinge = ?,
    Abgeschickt = NOW(),
    Bild1 = ?,
    Bild2 = ?,
    Bild3 = ?,
    Bild1Date = ?,
    Bild2Date = ?,
    Bild3Date = ?
WHERE
    mitarbeiterId = ?
`

type UpdateEinkaufParams struct {
	Paypal        bool
	Abonniert     bool
	Geld          sql.NullString
	Pfand         sql.NullString
	Dinge         sql.NullString
	Bild1         sql.NullString
	Bild2         sql.NullString
	Bild3         sql.NullString
	Bild1date     sql.NullTime
	Bild2date     sql.NullTime
	Bild3date     sql.NullTime
	Mitarbeiterid string
}

func (q *Queries) UpdateEinkauf(ctx context.Context, arg UpdateEinkaufParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateEinkauf,
		arg.Paypal,
		arg.Abonniert,
		arg.Geld,
		arg.Pfand,
		arg.Dinge,
		arg.Bild1,
		arg.Bild2,
		arg.Bild3,
		arg.Bild1date,
		arg.Bild2date,
		arg.Bild3date,
		arg.Mitarbeiterid,
	)
}

const updateLuieferant = `-- name: UpdateLuieferant :execresult
UPDATE
    Lieferanten
SET
    Firma = ?,
    Kundennummer = ?,
    Webseite = ?
WHERE
    id = ?
`

type UpdateLuieferantParams struct {
	Firma        string
	Kundennummer sql.NullString
	Webseite     sql.NullString
	ID           string
}

func (q *Queries) UpdateLuieferant(ctx context.Context, arg UpdateLuieferantParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateLuieferant,
		arg.Firma,
		arg.Kundennummer,
		arg.Webseite,
		arg.ID,
	)
}

const updatePreisWarenlieferung = `-- name: UpdatePreisWarenlieferung :execresult
UPDATE Warenlieferung SET Preis=NOW(), AlterPreis = ?, NeuerPreis = ? WHERE id = ?
`

type UpdatePreisWarenlieferungParams struct {
	Alterpreis sql.NullString
	Neuerpreis sql.NullString
	ID         int32
}

func (q *Queries) UpdatePreisWarenlieferung(ctx context.Context, arg UpdatePreisWarenlieferungParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updatePreisWarenlieferung, arg.Alterpreis, arg.Neuerpreis, arg.ID)
}

const updateUser = `-- name: UpdateUser :execresult
UPDATE
    Mitarbeiter
SET
    Name = ?,
    Short = ?,
    Gruppenwahl = ?,
    InternTelefon1 = ?,
    InternTelefon2 = ?,
    FestnetzAlternativ = ?,
    FestnetzPrivat = ?,
    HomeOffice = ?,
    MobilBusiness = ?,
    MobilPrivat = ?,
    Email = ?,
    Azubi = ?,
    Geburtstag = ?
WHERE
    id = ?
`

type UpdateUserParams struct {
	Name               string
	Short              sql.NullString
	Gruppenwahl        sql.NullString
	Interntelefon1     sql.NullString
	Interntelefon2     sql.NullString
	Festnetzalternativ sql.NullString
	Festnetzprivat     sql.NullString
	Homeoffice         sql.NullString
	Mobilbusiness      sql.NullString
	Mobilprivat        sql.NullString
	Email              sql.NullString
	Azubi              sql.NullBool
	Geburtstag         sql.NullTime
	ID                 string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUser,
		arg.Name,
		arg.Short,
		arg.Gruppenwahl,
		arg.Interntelefon1,
		arg.Interntelefon2,
		arg.Festnetzalternativ,
		arg.Festnetzprivat,
		arg.Homeoffice,
		arg.Mobilbusiness,
		arg.Mobilprivat,
		arg.Email,
		arg.Azubi,
		arg.Geburtstag,
		arg.ID,
	)
}

const updateWarenlieferung = `-- name: UpdateWarenlieferung :execresult
UPDATE Warenlieferung SET geliefert=NOW(), Name = ? WHERE id = ?
`

type UpdateWarenlieferungParams struct {
	Name string
	ID   int32
}

func (q *Queries) UpdateWarenlieferung(ctx context.Context, arg UpdateWarenlieferungParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateWarenlieferung, arg.Name, arg.ID)
}

const updateWiki = `-- name: UpdateWiki :execresult
UPDATE Wiki SET Name = ?, Inhalt = ?, created_at = NOW() WHERE id = ?
`

type UpdateWikiParams struct {
	Name   string
	Inhalt string
	ID     string
}

func (q *Queries) UpdateWiki(ctx context.Context, arg UpdateWikiParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateWiki, arg.Name, arg.Inhalt, arg.ID)
}
